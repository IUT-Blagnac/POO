:moduleTitle: BPOO
:authorDefault:  Dut/Info-S2/M2103
// include::lib/globals.asc[] // temporairement
:tdnum: TP 8
ifdef::eleve[]
:doctitle:  {moduleTitle} - Sujet {tdnum}
endif::eleve[]
ifdef::prof[]
:doctitle: {moduleTitle} - Support {tdnum}
endif::prof[]
ifdef::todoprof[]
:doctitle: {moduleTitle} - DEROULEMENT SEANCE PROF {tdnum}
endif::todoprof[]

= {doctitle}
:Author:  {authorDefault}
:lang: fr
:slideshowlocation: Your computer
:copyright: {date={localdate}}, {slideshowlocation} *** {author} *** Powered by AsciiDoc and W3C Slidy &#169; 
:incremental!:
:source-highlighter: pygments
:numbered:
:iconsdir: icons/
:icons: true

:eclipse: http://www.eclipse.org/[eclipse]
:eclipseversion: Indigo SR2
:eclipsedownload: http://www.eclipse.org/downloads/packages/eclipse-ide-java-developers/indigosr2[Eclipse Indigo sr2]

:docjava: http://docs.oracle.com/javase/7/docs/api/[documentation java]
:docjavaArrayList: http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html[documentation ArrayList<E>]

:junit: JUnit

//----------- définitions --------------
:sitecours: http://webetud.iut-blagnac.fr/[Support de Cours]
:pre: PreReq
:objtd: ObjTP
:duree: Durée
:depot: À rendre
:lien: Lien
:img: img

//-------------------- Warning si correction -----------
ifdef::prof[]
[IMPORTANT]
.Version corrigée
=====
Cette version comporte des indications pour les réponses aux exercices.
=====
endif::prof[]

//-------------------- Cartouche d'en-tête -----------

[icon="{iconsdir}/example.png"]
[IMPORTANT]
====
[[cartouche]]
[align="left",cols="1,10",width="90%"]
|======================
| {pre}		| Cours 4 : Héritage, TP7 : Héritage figures.
| {objtd}	| Programmer une hiérarchie d'héritage de Compte.
| {duree}	| *2 séance* de 1,5h sur machine.
| {depot}	| Code source à déposer : classes produites (un seul fichier zip) + réponses au questions éventuelles en commentaire en début de fichier dans les fichiers concernés.
|======================
====

ifdef::todoprof[]
[IMPORTANT]
====
Pour les profs :

* 	But du TP : Créer une hiérarchie de classes Compte.

**	On leur donne l'interface attendue des classes : toutes les méthodes qui seront dispos une fois la classe programmée
**	Ils doivent définir :

***	Les attributs nécessaires
***	*Les méthodes à ajouter*
***	*Les méthodes à redéfinir*
***	Et bien sur écrire le minimum de code

*	Le Cours 4 (cf en ligne moodle) a introduit l'héritage, les problématiques de constructeur (super(...)) et appel des méthodes héritées (super.methode(...)).
*	Le TP7 a déjà illustré le pb.
====

[IMPORTANT]
====

A Suivre :

*	Le choix des attributs, dans les classes
*	Ne pas redéfinir "trop" de méthodes

**	Eviter les défs du genre : +methode() { super.methode(); }+

*	Les appels à super.afficher() lorsque nécessaire.
====
endif::todoprof[]

ifndef::todoprof[]

== Objectif

Le but de ce TP est de construire une hiérarchie classes avec héritage à partir de la classe Compte déjà construite et utilisée dans d'autres TPs. 

On souhaite construire l'arborescence présentée figure ci-après.


[align="center"]
=====
.Diagramme UML des classes mises en oeuvre
[caption="Figure : "]
image:images/tp8.1.png[]
=====

== Mise en place de l'environnement

Récupérer les classes déjà écrites proposées sur le serveur (fichiers .zip) :

*	Compte.java :

**	Les Compte permettent de gérer des comptes simples comptabilisant des débits et des crédits successifs. L’interface de la classe Compte est disponible dans la documentation sur le serveur.
*	

== Étude des classes proposées

=== La classe CompteException

=== Les classes SensOperation et ...

== Travail à faire

=== Recommandations

*ATTENTION : Respectez les noms exacts des classes et méthodes (cf en-têtes fournis interfaces). Un programme de test vous est proposé.*

Pour chaque classe, écrire le code de la classe en faisant attention aux points suivants :

*	On ne redéfinira pas la méthode +soldeCompte()+ sur les sous-classes de Compte, en particulier sur CompteDepot. Elle devra calculer le bon solde telle qu’elle est définie dans la classe Compte. Elle y est définie final exprès (non redéfinissable).
*	La définition du(es) constructeur(s). Écrire le minimum de lignes possibles.
*	Quelles méthodes faut-il réellement redéfinir ? On écrira le minimum de code.
*	Redéfinir correctement +afficher()+ dans chaque classe.


=== Code à écrire

*Pour chaque classe demandée*, une à la fois, dans l'ordre proposé :

.	Créer un fichier portant le nom de la classe (aux majuscules près).
.	Écrire la classe selon les recommandations données ci-après
.	Écrire un petit test de la classe dans une méthode main() dans un fichier séparé.
.	Tester la méthode +afficher()+ et vérifier les valeurs affichées à l'écran ! Elles doivent être correctes.
.	Tester votre classe avec le test {junit} fourni.

== Spécification des classes à définir

=== La classe Cercle

La classe Cercle est une forme graphique comprenant les coordonnées du centre avec en plus un rayon (entier).

Écrire la classe Cercle. On définira :

.	la classe Cercle comme héritant de FormeGraphique,
.	le(s) attribut(s) nécessaire(s),
.	un constructeur par défaut initialisant les coordonnées du centre à 0 ainsi que le rayon à 0,

*	voir le cours pour les appels des constructeurs de la super-classe,
.	un constructeur paramétré permettant d'initialiser correctement toutes les données d'un Cercle,
.	une méthode accesseur (get) pour chaque attribut défini,
.	une méthode transformateur (set) pour chaque attribut défini,
.	redéfinir la méthode +surface()+ de calcul de la surface d'un Cercle (rappel : &Pi; x R^2^),

*	utiliser la constante &Pi; de la classe Math : Math.PI,
.	redéfinir la méthode +afficher()+ permettant d'afficher à l'écran le texte suivant. On appellera *obligatoirement* la méthode +afficher()+ de la classe parente.
+
*Forme graphique : abscisse* ~_valeur abcisse_~ *ordonnée* ~_valeur ordonnée_~
+
*Cercle : rayon* ~_valeur rayon_~
+
Exemple : 
+
 Forme graphique : abscisse 245 ordonnée 189
 Cercle : rayon 17

=== La classe Cylindre

La classe Cylindre est définie comme un cercle avec en plus une hauteur (entier).

Écrire la classe Cylindre. On définira :

.	un héritage éventuel pour la classe (assez évident),
.	le(s) attribut(s) nécessaire(s),
.	un constructeur par défaut initialisant les coordonnées du centre à 0, le rayon à 0 ainsi que la hauteur à 0,
.	un constructeur paramétré permettant d'initialiser correctement toutes les données d'un Cylindre,
.	une méthode accesseur (get) pour chaque attribut défini,
.	une méthode transformateur (set) pour chaque attribut défini,
.	la méthode +surface()+ qui calcule la surface d'un Cylindre (rappel : 2 x &Pi; x R x H + 2 x &Pi; x R^2^),
.	la méthode +volume()+ qui calcule le volume d'un Cylindre (rappel : &Pi; x R^2^ x H),
.	la méthode +afficher()+ permettant d'afficher à l'écran le texte suivant. On appellera *obligatoirement* la méthode +afficher()+ de la classe parente.
+
*Forme graphique : abscisse* ~_valeur abcisse_~ *ordonnée* ~_valeur ordonnée_~
+
*Cercle : rayon* ~_valeur rayon_~
+
*Cylindre : hauteur* ~_valeur hauteur_~
+
Exemple : 
+
 Forme graphique : abscisse 245 ordonnée 189
 Cercle : rayon 17
 Cylindre : hauteur 789


[NOTE]
=====
Compte tenu de l'héritage utilisé, en utilisant les méthodes transformateurs héritées : arrive-t-on à faire des "carrés qui ne soient pas vraiment carrés" ? 
====

ifdef::prof[]

== Solutions

[icon="{iconsdir}/solution.png"]
[IMPORTANT]
.Solutions
======
[source,java]
----

----
======

endif::prof[]

endif::todoprof[]
