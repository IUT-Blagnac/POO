:moduleTitle: BPOO
:authorDefault:  Dut/Info-S2/M2103
// include::lib/globals.asc[] // temporairement
:tdnum: TD 5
ifdef::eleve[]
:doctitle:  {moduleTitle} - Sujet {tdnum}
endif::eleve[]
ifdef::prof[]
:doctitle: {moduleTitle} - Support {tdnum}
endif::prof[]
ifdef::todoprof[]
:doctitle: {moduleTitle} - DEROULEMENT SEANCE PROF {tdnum}
endif::todoprof[]

= {doctitle}
:Author:  {authorDefault}
:lang: fr
:slideshowlocation: IUT Blagnac
:copyright: {date={localdate}}, {slideshowlocation} *** {author} *** Powered by AsciiDoc and W3C Slidy &#169; 
:incremental:
:source-highlighter: pygments
:numbered: true
:iconsdir: icons/
:icons: true

// eleve : sujet pour élèves
// prof : support prof pour séance
// todoprof : support AVEC EXPLICATIONS DEROULEMENT pour profs

//----------- définitions --------------
:sitecours: http://webetud.iut-blagnac.fr/[Support de Cours]
:pre: PreReq
:objtd: ObjTD
:duree: Durée
:depot: À rendre
:lien: Lien
:img: img

ifndef::todoprof[]
//-------------------- Warning si correction -----------
ifdef::prof[]
[CAUTION]
.Version corrigée
=====
Cette version comporte des indications pour les 
réponses aux exercices.
=====
endif::prof[]
endif::todoprof[]


//-------------------- Cartouche d'en-tête -----------
[[cartouche]]
[align="left",cols="1,10",width="90%"]
|======================
| {pre}		| TD1 : implantations mémoires, TD3 classes objets-encapsulation, TP2 : Utilisation d'objets.
| {objtd}	| *Stockage de données : listes chaînées*.
| {duree}	| *2 séances* de 1,5h
|======================
// // | {depot}	| -

ifdef::todoprof[]
[IMPORTANT]
====
Pour les profs :

. Objectif :

* Utiliser une liste chaînée
* Programmer une liste chaînée

. Viendra plus tard :

* TP : une liste simple pour les comptes (AgenceBancaire)

. Déroulement a priori :

* TODOTODO

====
endif::todoprof[]

ifndef::todoprof[]

== Principes

Une structure autoréferrentielle (parfois appelée structure récursive) correspond à une structure dont au moins un des champs contient une référence vers une structure de même type. 

De cette façon on crée des éléments *cellule* (appelés parfois noeuds ou liens) contenant des données, mais, contrairement à un tableau, celles-ci peuvent être éparpillées en mémoire et reliées entre elles par des liens logiques (des références), c'est-à-dire un ou plusieurs champs dans chaque structure contenant la référence d'une ou plusieurs structures de même type.

Plusieurs cas sont possibles :

*	Lorsque la structure contient des données et une référence vers la structure suivante : on parle de structure/liste chaînée.
*	Lorsque la structure contient des données, une référence vers la structure suivante, et une référence vers la structure précédente : on parle de liste chaînée double.
*	Lorsque la structure contient des données, une référence vers une première structure suivante, et une référence vers une seconde, on parle d'arbre binaire.

== Listes chaînées

On va considérer uniquement ici les structures chaînées de type liste simplement chaînée.

.	Pour gérer de telles listes, il faut :

* des éléments *cellule* contenant une valeur (contenu) et une référence vers la *cellule suivante*,
* repérer a minima la première *cellule* de la chaîne.

. Exemple de liste chaînée contenant des réels :
+
image:images/td5listechainee2.png[]
+
On a donc des *cellules* reliées entre elles comme des maillons d'un chaîne.

.	Attention : importance de la valeur *null* de la dernière Cellule -> repère la fin de la chaîne (dernier maillon).

.	Attention : +debutChaine+ est ici une variable "externe" à la structure chaînée. Il faut nécessairement repérer *au moins* le début de la structure chaînée (une variable, un attribut d'une classe plus tard, ...).

Question : Proposer un schéma de cette liste avec :

.	Un élément 35.5 de plus au début.
.	Un élément 75.5 de plus en fin.
.	L'élément 35.5 en moins.
.	L'élément 55.5 en moins.
.	L'élément 75.5 en moins.
.	Comment représenter une liste chaînée ne comportant aucune valeur ?

ifdef::prof[]
[icon="{iconsdir}/solution.png"]
[IMPORTANT]
.Réponse ajouts
======
image:images/td5listechainee1.png[]
======
endif::prof[]

ifdef::prof[]
[icon="{iconsdir}/solution.png"]
[IMPORTANT]
.Réponse suppressions
======
image:images/td5listechainee3.png[]
======
endif::prof[]

ifdef::prof[]
[icon="{iconsdir}/solution.png"]
[IMPORTANT]
.Réponse liste chaînée ne comportant aucune valeur
======
[source, java]
-----
debutChaine = null; // debutChaine ne référence aucune Cellule
-----
======
endif::prof[]

== Utiliser "manuellement" une liste chaînée

=== La classe Cellule

Afin de pouvoir gérer les cellules d'une liste chaînée, on propose la classe ci-dessous :

.Diagramme UML de la classe Cellule
[caption="Figure : "]
image:images/classeCellule.png[]

.Source java de la classe Cellule
[source, java]
-----
public class Cellule {
	private double contenu; 
	private Cellule suivant;
	
	public Cellule (double pVal, Cellule pSuiv) {
		this.contenu = pVal;
		this.suivant = pSuiv;
	}
	public double getContenu () {
		return this.contenu;
	}
	public Cellule getSuivant () {
		return this.suivant;
	}
	public void setContenu (double pVal) {
		this.contenu = pVal;
	}
	public void setSuivant (Cellule pSuiv) {
		this.suivant = pSuiv;
	}
}
-----

////////////////////
.	Question : Ecrire le code (simple) de la classe Cellule.

ifdef::prof[]
[icon="{iconsdir}/solution.png"]
[IMPORTANT]
.Réponse classe Cellule
======
[source, java]
-----
public class Cellule {
	private double contenu; 
	private Cellule suivant;
	
	public Cellule (double pVal, Cellule pSuiv) {
		this.contenu = pVal;
		this.suivant = pSuiv;
	}
	public double getContenu () {
		return this.contenu;
	}
	public Cellule getSuivant () {
		return this.suivant;
	}
	public void setContenu (double pVal) {
		this.contenu = pVal;
	}
	public void setSuivant (Cellule pSuiv) {
		this.suivant = pSuiv;
	}
}
-----
======
endif::prof[]
////////////////////


=== Utiliser la classe Cellule

Écrire le programme simple proposé en annexe.

La partie 1 doit permettre de construire :

image:images/td5listechainee2.png[]

La partie 2 doit permettre de construire :

image:images/td5listechainee1.png[]

La partie 3 doit permettre de construire :

image:images/td5listechainee3.png[]

== Différence tableau <> liste chaînée simple

Donner les différences entre tableaux et listes chaînées simples dans les situations suivantes :

. Ajout d'un élément en fin.
. Ajout au début.
. Suppression d'un élément (début, milieu, fin).
. Accès élément i.


ifdef::prof[]
[icon="{iconsdir}/solution.png"]
[IMPORTANT]
.Réponses
======
. Tableau 
.. Ajout d'un élément en fin : si plein => créer un autre tableau + recopie
.. Ajout au début : si plein => créer un autre tableau + recopie + décalage
.. Suppression d'un élément (début, milieu, fin) : décalage de tout le tableau (sauf fin) + éventuellement diminution de la taille du tableau (?).
.. Accès élément i : immédiat
. Liste chaînée 
.. Ajout d'un élément en fin : parcours liste + ajout une cellule. On pourrait aussi conserver la référence de la fin de la liste.
.. Ajout au début : immédiat + création d'une cellule.
.. Suppression d'un élément (début, milieu, fin)
... début : immédiat (une ligne)
... milieu et fin : rechercher (parcours) le précédent et modification d'une référence
.. Accès élément i : parcours des (i-1) éléments précédents.
======
endif::prof[]

endif::todoprof[]

