:moduleTitle: BPOO
:authorDefault:  Dut/Info-S2/M2103
// include::lib/globals.asc[] // temporairement
:tdnum: TD 6
ifdef::eleve[]
:doctitle:  {moduleTitle} - Sujet {tdnum}
endif::eleve[]
ifdef::prof[]
:doctitle: {moduleTitle} - Support {tdnum}
endif::prof[]
ifdef::todoprof[]
:doctitle: {moduleTitle} - DEROULEMENT SEANCE PROF {tdnum}
endif::todoprof[]

= {doctitle}
:Author:  {authorDefault}
:lang: fr
:slideshowlocation: IUT Blagnac
:copyright: {date={localdate}}, {slideshowlocation} *** {author} *** Powered by AsciiDoc and W3C Slidy &#169; 
:incremental:
:source-highlighter: pygments
:numbered: true
:iconsdir: icons/
:icons: true

// eleve : sujet pour élèves
// prof : support prof pour séance
// todoprof : support AVEC EXPLICATIONS DEROULEMENT pour profs

//----------- définitions --------------
:sitecours: http://webetud.iut-blagnac.fr/[Support de Cours]
:pre: PreReq
:objtd: ObjTD
:duree: Durée
:depot: À rendre
:lien: Lien
:img: img

ifndef::todoprof[]
//-------------------- Warning si correction -----------
ifdef::prof[]
[CAUTION]
.Version corrigée
=====
Cette version comporte des indications pour les 
réponses aux exercices.
=====
endif::prof[]
endif::todoprof[]


//-------------------- Cartouche d'en-tête -----------
[[cartouche]]
[align="left",cols="1,10",width="90%"]
|======================
| {pre}		| Tableaux dynamiques, structures chaînées.
| {objtd}	| *Mettre en oeuvre en java une classe Ensemble*.
| {duree}	| *1 séances* de 1,5h
|======================
// // | {depot}	| -

ifdef::todoprof[]
[IMPORTANT]
====
Pour les profs :

. Objectif :

* 	Mise en oeuvre d'un type
*	Choix d'implémentation
*	Mise en oeuvre d'algorithmes plus complexes

//////
. Déroulement a priori :

*	15' : Principes
*	30' : 0..1-0..1
*	45' : 0..1-0..*
///////

====
endif::todoprof[]

ifndef::todoprof[]

== Domaine d'étude

On s'intéresse dans ce TD à la mise en oeuvre d'une classe *Ensemble ordonné* de chaînes de caractères.

Un ensemble ordonné est une *collection ordonnée qui n'accepte pas les doublons*.

*	Par exemple, un ensemble de String n'accepte qu'une seule fois la valeur "bonjour". Par contre "bonjour" et "BONjour" sont acceptées.
*	L'ensemble constitué des trois valeurs "a", "d", "b", "c" sera ordonné en { "a", "b", "c", "d" }.
*	On supposera dans tout l'exercice que la valeur null est refusée (non ajoutée, non enlevé, non recherchée).

Le diagramme UML suivant indique l'interface générale de la classe attendue.
[caption="Figure : "] 
image:images/td6newOSSgeneral.png[]

==	Réflexion sur la mise en oeuvre

Dans un premier temps, on imagine deux implémentations :

*	par liste chaînée simplement chaînée comme déjà vu,
*	par tableau dynamique comme déjà vu : le tableau a, à tout moment, une taille de celle du nombre d'éléments contenus dans l'ensemble.
+
[NOTE]
======
une implémentation par ArrayList<E> serait plus simple à mettre en oeuvre mais relève de la même approche : un tableau agrandi "dynamique".
======


*Question* : Indiquer rapidement les avantages de chaque approche :

*	pour l'insertion :
**	Tableau dynamique :
+
.
+
.
+
.

**	Liste chaînée :
+
.
+
.
+
.

*	pour la suppression
**	Tableau dynamique :
+
.
+
.
+
.

**	Liste chaînée :
+
.
+
.
+
.

*	pour la recherche (contains) :
**	Tableau dynamique :
+
.
+
.
+
.

**	Liste chaînée :
+
.
+
.
+
.

ifdef::prof[]
[icon="{iconsdir}/solution.png"]
[IMPORTANT]
.Réponse
============
*	pour l'insertion :
**	Tableau dynamique : 
***	Nécessite de trouver si l'élément n'existe pas avant de l'insérer afin de créer un tableau plus grand.
***	Insertion en début, milieu, fin (ensemble ordonné).
**	Liste chaînée :
***	On peut rechercher la place de l'élément en même temps que son existence et l'ajouter dés que sa place est trouvée (ensemble ordonné).
*	pour la suppression
**	Tableau dynamique :
***	Nécessite de trouver si l'élément existe avant de le supprimer afin de créer un tableau plus petit.
***	Suppression en début, milieu, fin (ensemble ordonné).
**	Liste chaînée :
***	On peut rechercher l'élément et le supprimer dés que sa place est trouvée (ensemble ordonné).
*	pour la recherche (contains) :
**	Tableau dynamique : 
***	Recherche dichotomique : trouve en log2 (n) maxi -> on le dit de complexité O (log2 (n))
**	Liste chaînée :
***	Linéaire : trouve en n maxi -> on le dit de complexité O (n)
============

[NOTE]
======
-----
           log2 (10) == 3.32
          log2 (100) == 6.64
        log2 (1 000) == 9.96
       log2 (10 000) == 13.28
    log2 (1 000 000) == 19.93
log2 (1 000 000 000) == 29.89
-----
======

endif::prof[]

==	Mise en oeuvre par tableau dynamique

On retient la mise ne oeuvre par tableau dynamique.

Le diagramme UML suivant indique la conception réalisée pour cette implémentation.
[caption="Figure : "] 
image:images/td6newOSStabDyn.png[]

Quelques exemples :

.	+OrderedStringSet oss = new OrderedStringSet()+ => valeurs :
+
-----
||  // Tableau de longueur 0
++
||  
-----

.	+oss.add("S3");+ => valeurs :
+
-----
|  0 | 
+----+
|"S3"|  // Attention => en vrai des références
-----

.	+oss.add("S1");+ => valeurs :
+
-----
| 0  | 1  |
+----+----+
|"S1"|"S3"|  // Attention => en vrai des références
-----

.	+oss.add("S2");+ => valeurs :
+
-----
| 0  | 1  | 2  |
+----+----+----+
|"S1"|"S2"|"S3"|  // Attention => en vrai des références
-----

.	+oss.add("S1");+ => valeurs :
+
-----
| 0  | 1  | 2  |
+----+----+----+
|"S1"|"S2"|"S3"|  // Attention => en vrai des références
-----

.	+oss.add(null);+ => valeurs :
+
-----
| 0  | 1  | 2  |
+----+----+----+
|"S1"|"S2"|"S3"|  // Attention => en vrai des références
-----

.	+oss.contains("S2")+ => true
.	+oss.contains("S1")+ => true
.	+oss.contains("toto")+ => false
.	+oss.contains("s1")+ => false
.	+oss.contains(null)+ => false

.	+oss.remove(null);+ => valeurs :
+
-----
| 0  | 1  | 2  |
+----+----+----+
|"S1"|"S2"|"S3"|  // Attention => en vrai des références
-----

.	+oss.remove("s2");+ => valeurs :
+
-----
| 0  | 1  | 2  |
+----+----+----+
|"S1"|"S2"|"S3"|  // Attention => en vrai des références
-----

.	+oss.remove("toto");+ => valeurs :
+
-----
| 0  | 1  | 2  |
+----+----+----+
|"S1"|"S2"|"S3"|  // Attention => en vrai des références
-----

.	+oss.remove("S2");+ => valeurs :
+
-----
| 0  | 1  |
+----+----+
|"S1"|"S3"|  // Attention => en vrai des références
-----

.	+oss.remove("S1");+ => valeurs :
.	+oss.remove("S3");+ => valeurs :
+
-----
||
+----+----+
||
-----

*Question* : Ecrire les méthodes de la classe

*	On vous donne la méthode +trouveRang(String s)+
*	Ecrire dans l'ordre : le constructeur, size, contains, add, toArray. remove a déjà été écrite en TP (Agence bancaire).
*	Ecrire les méthodes qui renvoient *un nouvel objet OrderedStringSet* : union (receveur union paramètre), difference (receveur "moins" paramètre), intersect (receveur intersection paramètre)

**	Ces méthodes sont elles des transformateurs ? des accesseurs (observateurs) ?

ifdef::prof[]
[icon="{iconsdir}/solution.png"]
[IMPORTANT]
.Réponse
======
La méthode +void associerClient (Client cli)+ dans la classe Commande réalise le traitement :

*	Si le paramètre cli est null : défaire l'association :

**	Si la Commande est déjà associée à un Client : enlever la Commande de ce Client.
** 	Lier la Commande à null (setClient()).

*	Si le paramètre cli n'est pas null : construire une association :

**	Si la Commande est déjà associée à un Client : enlever la Commande de ce Client.
**	Créer les liens pour associer la Commande et cli (setClient() et addCommande()).

[source,java]
----
class Commande {
	// ...
	public void associerClient (Client cli) {
	    if (cli == null ){ // Défaire l'association
	        if (this.leClient != null) {
	        	this.leClient.removeCommande(this);
	        }
	        this.setClient(null); // Ou this.leClient = null ;	    	
	    } else { // Créer l'association
	    	if (this.leClient != null) {
	    		this.leClient.removeCommande(this);
	    	}
	    	this.setClient(cli); // Ou this.leClient = cli;
	    	cli.addCommande(this);
	    }
	}	
}

//A Noter : si l'association existait déjà => elle est "effacée" et "recréée".

----

La méthode +public void associerCommande (Commande comm)+ dans la classe Client réalise le traitement :

*	Si le paramètre comm est null : ne rien faire.
*	Si comm est déjà enregistrée comme Commande de ce Client : ne rien faire.
*	Si comm est associé à un Client : défaire cette association (removeCommande()).
*	Créer les liens pour associer le Client et comm (setClient() et addCommande()).

[source,java]
----
class Client {
	// ...	
	public void associerCommande (Commande comm) {
	    if (comm != null) {
	    	if(!this.lesCommandes.contains(comm)) { // Peut être enlevé
			                                        // Efface et recrée l'association
		        if (comm.getClient() != null ) {
		        	comm.getClient().removeCommande(comm);
		        }
		        this.lesCommandes.add ( comm ); // Ou this.addCommande(comm);
		        comm.setClient ( this );
	    	}
	    }
	}
}
----

La méthode +public void defaireAssoCommande (Commande comm)+ dans la classe Client :

*	Si le paramètre comm est null : ne rien faire.
*	Si la comm N'est PAS enregistrée comme Commande de ce Client : ne rien faire.
*	Défaire les liens entre le Client et comm (removeCommande() et setClient(null)).


[source,java]
----
class Client {
	// ...	
	public void defaireAssoCommande (Commande comm) {
	    if (comm != null) {
	    	if(this.lesCommandes.contains(comm)) {
		        this.lesCommandes.remove ( comm ); // Ou this.removeCommande(comm);
		        comm.setClient ( null );
	    	}
	    }
	}
}
----
======
endif::prof[]

endif::todoprof[]

