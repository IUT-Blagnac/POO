:moduleTitle: BPOO
:authorDefault:  Dut/Info-S2/M2103
// include::lib/globals.asc[] // temporairement
:tdnum: TD 6
ifdef::eleve[]
:doctitle:  {moduleTitle} - Sujet {tdnum}
endif::eleve[]
ifdef::prof[]
:doctitle: {moduleTitle} - Support {tdnum}
endif::prof[]
ifdef::todoprof[]
:doctitle: {moduleTitle} - DEROULEMENT SEANCE PROF {tdnum}
endif::todoprof[]

= {doctitle}
:Author:  {authorDefault}
:lang: fr
:slideshowlocation: IUT Blagnac
:copyright: {date={localdate}}, {slideshowlocation} *** {author} *** Powered by AsciiDoc and W3C Slidy &#169; 
:incremental:
:source-highlighter: pygments
:numbered: true
:iconsdir: icons/
:icons: true

// eleve : sujet pour élèves
// prof : support prof pour séance
// todoprof : support AVEC EXPLICATIONS DEROULEMENT pour profs

//----------- définitions --------------
:sitecours: http://webetud.iut-blagnac.fr/[Support de Cours]
:pre: PreReq
:objtd: ObjTD
:duree: Durée
:depot: À rendre
:lien: Lien
:img: img

ifndef::todoprof[]
//-------------------- Warning si correction -----------
ifdef::prof[]
[CAUTION]
.Version corrigée
=====
Cette version comporte des indications pour les 
réponses aux exercices.
=====
endif::prof[]
endif::todoprof[]


//-------------------- Cartouche d'en-tête -----------
[[cartouche]]
[align="left",cols="1,10",width="90%"]
|======================
| {pre}		| Tableaux dynamiques, structures chaînées.
| {objtd}	| *Mettre en oeuvre en java une classe Ensemble*.
| {duree}	| *1 séances* de 1,5h
|======================
// // | {depot}	| -

ifdef::todoprof[]
[IMPORTANT]
====
Pour les profs :

. Objectif :

* 	Mise en oeuvre d'un type
*	Choix d'implémentation
*	Mise en oeuvre d'algorithmes plus complexes

.	Pb potentiels :

*	Les algos (add/remove) sont durs : laisser chercher quand même
*	Commencer par contains
*	Dichotomie : vue en S1.

Autre algo possible : chercher par dichotomie le rang où insérer un élt pour faire le add par deux for (recopie début, ajout, recopie fin).

//////
. Déroulement a priori :

*	15' : Principes
*	30' : 0..1-0..1
*	45' : 0..1-0..*
///////

====
endif::todoprof[]

ifndef::todoprof[]

== Domaine d'étude : implémenter un ensemble ordonné de String

On s'intéresse dans ce TD à la mise en oeuvre d'une classe *Ensemble ordonné* de chaînes de caractères.

Le diagramme UML suivant montre l'interface générale de la classe attendue.

[caption="Figure : "] 
image:images/td6newOSSgeneral.png[]

Un ensemble ordonné est une *collection ordonnée qui n'accepte pas les doublons* :

*	Par exemple, un ensemble de String n'accepte qu'une seule fois la valeur "bonjour". Par contre "bonjour" et "BONjour" sont acceptées.
*	L'ensemble constitué des valeurs "a", "d", "b", "c" sera ordonné en { "a", "b", "c", "d" }.
*	Après chaque ajout, l'ensemble est ordonné.
*	Une approche par programmation par contrats est utilisée : lors des opérations add/remove :

**	L'ajout d'une chaîne déjà présente ne réalise aucun ajout sans levée d'exception ; on aurait pu renvoyer un booléen.
**	La suppression d'une chaîne non présente ne réalise aucune suppression sans levée d'exception ; on aurait pu renvoyer un booléen.
**	_On supposera dans tout l'exercice que la valeur null est refusée (non ajoutée, non enlevé, non recherchée, sans levée d'exception)._

==	Réflexion sur la mise en oeuvre

Dans un premier temps, on imagine deux implémentations :

*	par structure chaînée (simplement chaînée) comme déjà vu,
*	par tableau dynamique comme déjà vu : le tableau a, à tout moment, une taille de celle du nombre d'éléments contenus dans l'ensemble.
+
[NOTE]
======
Une implémentation par ArrayList<E> serait plus simple à mettre en oeuvre mais relève de la même approche : un tableau "dynamique".
======


*Questions* : Indiquer rapidement les solutions pour mettre en oeuvre (quoi faire) les opérations dans chaque approche :

*	Pour l'insertion (add) :
**	Tableau dynamique :
+
.
+
.
+
.

**	Liste chaînée :
+
.
+
.
+
.

*	Pour la suppression (remove) :
**	Tableau dynamique :
+
.
+
.
+
.

**	Liste chaînée :
+
.
+
.
+
.

*	Pour la recherche (contains) :
**	Tableau dynamique :
+
.
+
.
+
.

**	Liste chaînée :
+
.
+
.
+
.

ifdef::prof[]
[icon="{iconsdir}/solution.png"]
[IMPORTANT]
.Réponse
============
*	Pour l'insertion :
**	Tableau dynamique : 
***	Nécessite de trouver si l'élément n'existe pas avant de l'insérer afin de créer un tableau plus grand.
***	Insertion en début, milieu, fin (ensemble ordonné).
**	Liste chaînée :
***	On peut rechercher la place de l'élément en même temps que son existence et l'ajouter dés que sa place est trouvée (ensemble ordonné).
*	Pour la suppression
**	Tableau dynamique :
***	Nécessite de trouver si l'élément existe avant de le supprimer afin de créer un tableau plus petit.
***	Suppression en début, milieu, fin (ensemble ordonné).
**	Liste chaînée :
***	On peut rechercher l'élément et le supprimer dés que sa place est trouvée (ensemble ordonné).
*	Pour la recherche (contains) :
**	Tableau dynamique : 
***	Recherche dichotomique : trouve en log2 (n) maxi -> on dit l'algorithme de complexité O (log2 (n))
**	Liste chaînée :
***	Linéaire : trouve en n maxi -> on dit l'algorithme de complexité O (n)
============

[NOTE]
======
-----
           log2 (10) == 3.32
          log2 (100) == 6.64
        log2 (1 000) == 9.96
       log2 (10 000) == 13.28
    log2 (1 000 000) == 19.93
log2 (1 000 000 000) == 29.89
-----

[NOTE]
======
======
Pour les tableaux dynamiques
======

endif::prof[]

==	Mise en oeuvre par tableau dynamique

=== Principes 

On retient une mise en oeuvre par tableau dynamique.

Le diagramme UML suivant montre la conception réalisée pour cette implémentation.
[caption="Figure : "] 
image:images/td6newOSStabDyn.png[]

Quelques exemples d'opérations et de résultat :

.	+OrderedStringSet oss = new OrderedStringSet()+ :
+
-----
tableau  ||  // Tableau de longueur 0
valeurs  ++
         ||  
-----

.	+oss.add("S3");+ :
+
-----
tableau  |  0 | 
valeurs  +----+
         |"S3"|  // Attention => en vrai des références
-----

.	+oss.add("S1");+ :
+
-----
tableau  | 0  | 1  |
valeurs  +----+----+
         |"S1"|"S3"|  // Attention => en vrai des références
-----

.	+oss.add("S2");+ :
+
-----
tableau  | 0  | 1  | 2  |
valeurs  +----+----+----+
         |"S1"|"S2"|"S3"|  // Attention => en vrai des références
-----

.	+oss.add("S1");+ :
+
-----
tableau  | 0  | 1  | 2  |
valeurs  +----+----+----+
         |"S1"|"S2"|"S3"|  // Attention => en vrai des références
-----

.	+oss.add(null);+ :
+
-----
tableau  | 0  | 1  | 2  |
valeurs  +----+----+----+
         |"S1"|"S2"|"S3"|  // Attention => en vrai des références
-----

.	+oss.contains("S2")+ => true
.	+oss.contains("S1")+ => true
.	+oss.contains("toto")+ => false
.	+oss.contains("s1")+ => false
.	+oss.contains(null)+ => false

.	+oss.remove(null);+:
+
-----
tableau  | 0  | 1  | 2  |
valeurs  +----+----+----+
         |"S1"|"S2"|"S3"|  // Attention => en vrai des références
-----

.	+oss.remove("s2");+ :
+
-----
tableau  | 0  | 1  | 2  |
valeurs  +----+----+----+
         |"S1"|"S2"|"S3"|  // Attention => en vrai des références
-----

.	+oss.remove("toto");+ :
+
-----
tableau  | 0  | 1  | 2  |
valeurs  +----+----+----+
         |"S1"|"S2"|"S3"|  // Attention => en vrai des références
-----

.	+oss.remove("S2");+ :
+
-----
tableau  | 0  | 1  |
valeurs  +----+----+
         |"S1"|"S3"|  // Attention => en vrai des références
-----

.	+oss.remove("S1");+
.	+oss.remove("S3");+ :
+
-----
tableau  ||
valeurs  ++
         ||
-----

=== Réalisation 

Certaines méthodes de la classe sont déjà données :

*	On vous donne la méthode +trouveRang(String s)+ en version non optimisée.
*	On vous donne aussi : le constructeur, +size+, +toArray+.

*Ecrire le corps des méthodes suivantes :*

*	+contains+, +add+, +remove+.
*	Ecrire les méthodes qui renvoient *un nouvel objet OrderedStringSet* : +union+ (receveur union paramètre), +difference+ (receveur "moins" paramètre), +intersect+ (receveur intersection paramètre)

**	Ces méthodes sont elles des transformateurs ? des accesseurs (observateurs) ?
*	Récrire +trouveRang(String s)+ avec une recherche par dichotomie.

[NOTE]
======
Comparaison de chaînes de caractères :  +public int compareTo(String anotherString)+

*	Compares two strings lexicographically. The comparison is based on the Unicode value of each character in the strings. The character sequence represented by this String object is compared lexicographically to the character sequence represented by the argument string. The result is a negative integer if this String object lexicographically precedes the argument string. The result is a positive integer if this String object lexicographically follows the argument string. The result is zero if the strings are equal; compareTo returns 0 exactly when the equals(Object) method would return true.
*	*Parameters*: 	anotherString - the String to be compared.
*	*Returns*:	the value 0 if the argument string is equal to this string; a value less than 0 if this string is lexicographically less than the string argument; and a value greater than 0 if this string is lexicographically greater than the string argument.
======

ifdef::prof[]

[icon="{iconsdir}/solution.png"]
[IMPORTANT]
.Réponses
======
[source,java]
----
public class OrderedStringSet {

	private String[] valeurs;

	public OrderedStringSet() {
		this.valeurs = new String[0];
	}

	public int size() {
		return this.valeurs.length;
	}

	private int trouveRang(String s) {
		int deb, fin, milieu;
		deb = 0;
		fin = this.valeurs.length - 1;

		while (deb <= fin) {
			milieu = (deb + fin) / 2;
			if (this.valeurs[milieu].compareTo(s) == 0) {
				return milieu;
			} else if (this.valeurs[milieu].compareTo(s) < 0) {
				deb = milieu + 1;
			} else {
				fin = milieu - 1;
			}
		}

		return -1;
	}

	public void add(String s) {
		int rang, i, j;
		boolean insere;

		if (s == null) {
			return;
		}

		rang = this.trouveRang(s);
		if (rang != -1) { // Si existe : stop
			return;
		}

		String nt[];
		// Créer le tableau
		nt = new String[this.valeurs.length + 1];

		insere = false;
		j = 0;
		for (i = 0; i < this.valeurs.length; i++) {
			if (insere) {
				// Si déja placé : simple recopie
				nt[j] = this.valeurs[i];
				j++;
			} else {
				if (this.valeurs[i].compareTo(s) < 0) {
					// Si après : recopie
					nt[j] = this.valeurs[i];
					j++;
				} else {
					// Si avant : insérer et recopier
					nt[j] = s;
					j++;
					nt[j] = this.valeurs[i];
					j++;
					insere = true;
				}
			}
		}
		if (!insere) { // si pas encore insérer : le faire(dernier)
			nt[nt.length - 1] = s;
		}

		this.valeurs = nt;

		// Reinit iterateur
		this.initParcours();
	}

	public void remove(String s) {
		int rang, i, j;

		if (s == null) {
			return;
		}

		rang = this.trouveRang(s);
		if (rang == -1) {
			// Si n'existe pas : stop
			return;
		}

		String nt[];
		// Créer le tableau
		nt = new String[this.valeurs.length - 1];

		j = 0;
		// Recopier jusqu'à rang exclu
		for (i = 0; i < rang; i++) {
			nt[j] = this.valeurs[i];
			j++;
		}
		// Recopier à partir de (rang+1)
		for (i = rang + 1; i < this.valeurs.length; i++) {
			nt[j] = this.valeurs[i];
			j++;
		}
		this.valeurs = nt;

		// Reinit iterateur
		this.initParcours();
	}

	public boolean contains(String s) {
		if (s == null) {
			return false;
		}

		return this.trouveRang(s) != -1;
	}

	public String[] toArray() {
		String resultat[];
		resultat = new String[this.valeurs.length];
		int i;
		for (i = 0; i < this.valeurs.length; i++) {
			resultat[i] = this.valeurs[i];
		}
		return resultat;
	}

	public OrderedStringSet union(OrderedStringSet oss) {
		OrderedStringSet resultat = new OrderedStringSet();
		String[] temp;

		temp = oss.toArray();
		for (int i = 0; i < temp.length; i++) {
			resultat.add(temp[i]);
		}
		for (int i = 0; i < this.valeurs.length; i++) {
			resultat.add(this.valeurs[i]);
		}

		return resultat;
	}

	public OrderedStringSet difference(OrderedStringSet oss) {
		OrderedStringSet resultat = new OrderedStringSet();

		for (int i = 0; i < this.valeurs.length; i++) {
			if (!oss.contains(this.valeurs[i])) {
				resultat.add(this.valeurs[i]);
			}
		}

		return resultat;
	}

	public OrderedStringSet intersect(OrderedStringSet oss) {
		OrderedStringSet resultat = new OrderedStringSet();

		for (int i = 0; i < this.valeurs.length; i++) {
			if (oss.contains(this.valeurs[i])) {
				resultat.add(this.valeurs[i]);
			}
		}

		return resultat;
	}
}
----

======
endif::prof[]

endif::todoprof[]

