:moduleTitle: BPOO
:authorDefault:  Dut/Info-S2/M2103
// include::lib/globals.asc[] // temporairement
:tdnum: TP 7
ifdef::eleve[]
:doctitle:  {moduleTitle} - Sujet {tdnum}
endif::eleve[]
ifdef::prof[]
:doctitle: {moduleTitle} - Support {tdnum}
endif::prof[]
ifdef::todoprof[]
:doctitle: {moduleTitle} - DEROULEMENT SEANCE PROF {tdnum}
endif::todoprof[]

= {doctitle}
:Author:  {authorDefault}
:lang: fr
:slideshowlocation: Your computer
:copyright: {date={localdate}}, {slideshowlocation} *** {author} *** Powered by AsciiDoc and W3C Slidy &#169; 
:incremental!:
:source-highlighter: pygments
:numbered:
:iconsdir: icons/
:icons: true

:eclipse: http://www.eclipse.org/[eclipse]
:eclipseversion: Indigo SR2
:eclipsedownload: http://www.eclipse.org/downloads/packages/eclipse-ide-java-developers/indigosr2[Eclipse Indigo sr2]

:docjava: http://docs.oracle.com/javase/7/docs/api/[documentation java]
:docjavaArrayList: http://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html[documentation ArrayList<E>]

:junit: JUnit

//----------- définitions --------------
:sitecours: http://webetud.iut-blagnac.fr/[Support de Cours]
:pre: PreReq
:objtd: ObjTP
:duree: Durée
:depot: À rendre
:lien: Lien
:img: img

//-------------------- Warning si correction -----------
ifdef::prof[]
[IMPORTANT]
.Version corrigée
=====
Cette version comporte des indications pour les réponses aux exercices.
=====
endif::prof[]

//-------------------- Cartouche d'en-tête -----------

[icon="{iconsdir}/example.png"]
[IMPORTANT]
====
[[cartouche]]
[align="left",cols="1,10",width="90%"]
|======================
| {pre}		| Cours 4 : Héritage.
| {objtd}	| Programmer une hiérarchie d'héritage simple.
| {duree}	| *2 séance* de 1,5h sur machine.
| {depot}	| Code source à déposer : Classes produites (un seul fichier zip) + réponses au questions éventuelles en commentaire en début de fichier.
|======================
====

ifdef::todoprof[]
[IMPORTANT]
====
Pour les profs :

* 	But du TP : Créer une hiérarchie de classes simples.
*	Le Cours 4 (cf en ligne moodle) a introduit l'héritage, les problématiques de constructeur (super(...)) et appel des méthodes héritées (super.methode(...)).
*	Le TD7 illustrera les exemples de cours mais a lieu avant ou après les TPs ...
====

[IMPORTANT]
====

A Suivre :

*	Le choix des attributs, surtout Sphere et Carre qui n'en ont pas.
*	Ne pas faire d'attributs pour surface et volume de Sphere : juste redéfinir les méthodes héritées.
*	Ne pas faire d'attribut pour Carré qui passe son côté comme longueur et largeur du Rectangle.
*	Le constructeur de Carré un peu particulier (Carre (x, y, cote)).
*	L'héritage (ne pas faire de compositions même si le sujet s'y prêterai bien parfois).
*	Les appels de constructeurs.
*	Les appels à super.afficher() lorsque nécessaire.
====
endif::todoprof[]

ifndef::todoprof[]

== Objectif

Le but de ce TP est de construire une hiérarchie simple de classes avec héritage et de tester les classes produites.

////////////////////////////////////
[align="center"]
=====
TODO PUT IMAGE !!!!!
.Diagramme UML des classes mises en oeuvre
[caption="Figure : "]
image:images/tp6-AG-Compte.png[]
=====
////////////////////////////////////

On souhaite construire l'arborescence suivante :

    FormeGraphique
        Cercle
            Cylindre
            Sphere
        Rectangle
            Carré

== Travail à faire

=== Code à écrire

*Pour chaque classe*, une à la fois, dans l'ordre proposé (Sphere et Carre tout à la fin) :

.	Écrire la classe selon les recommandations données ci-après
+
[NOTE]
=====
On ne traitera pas de cas d'erreurs avec levée d'exceptions dans ce sujet. 
====
+
.	Écrire un petit test de la classe dans une méthode main()

*	Créer un objet avec chaque constructeur.
*	Pour chaque objet créé :
**	Lui appliquer la méthode +afficher()+.
**	Lui appliquer les méthodes transformateurs de la classe.
**	Lui appliquer les méthodes accesseurs de la classe (dans un System.out.println()).
**	Lui appliquer les méthodes transformateurs héritées.
**	Lui appliquer les méthodes accesseurs héritées.
**	Lui appliquer la méthode +afficher()+.
.	Vérifier les valeurs affichées à l'écran ! Elles doivent être correctes.
+
[NOTE]
=====
Au besoin : commenter au fur et à mesure le code écrit pour tester chaque classe dans le main().

*MAIS NE PAS LES EFFACER, SERA UTILE A LA FIN !!*
====

=== Spécification (simple) de chaque classe

==== La classe FormeGraphique

La classe FormeGraphique définit une forme graphique par ses coordonnées sur le plan x et y (entiers).

Écrire la classe FormeGraphique. On définira :

.	le(s) attribut(s) nécessaire(s),
.	un constructeur par défaut initialisant les coordonnées à 0,
.	un constructeur paramétré permettant d'initialiser correctement les coordonnées de la FormeGraphique,
.	une méthode accesseur (get) pour chaque attribut défini,
.	une méthode transformateur (set) pour chaque attribut défini,
.	la méthode qui calcule la surface d'une forme, valeur de type +double+. A ce niveau, elle est de 0,
.	la méthode qui calcule le volume d'une forme, valeur de type +double+. A ce niveau, il est de 0,
.	la méthode afficher permettant d'afficher à l'écran le texte suivant :
+
*Forme graphique : abscisse * ~_valeur abcisse_~ *ordonnée* ~_valeur ordonnée_~
+
Exemple : 
+
 Forme graphique : abscisse 245 ordonnée 189

==== La classe Cercle

La classe Cercle est une forme graphique avec en plus un rayon (entier).

Écrire la classe Cercle. On définira :

.	la classe Cercle comme héritant de FormeGraphique,
.	le(s) attribut(s) nécessaire(s),
.	un constructeur par défaut initialisant les coordonnées à 0 ainsi que le rayon à 0,

*	voir le cours pour les appels des constructeurs de la super-classe,
.	un constructeur paramétré permettant d'initialiser correctement toutes les données d'un Cercle,
.	une méthode accesseur (get) pour chaque attribut défini,
.	une méthode transformateur (set) pour chaque attribut défini,
.	la méthode qui calcule la surface d'un Cercle (rappel : PI x rayon^2^),

*	utiliser la constante PI de la classe Math : Math.PI,
.	la méthode afficher permettant d'afficher à l'écran le texte suivant. On appelera *obligatoirement* la méthode +afficher()+ de la classe parente.
+
*Forme graphique : abscisse* ~_valeur abcisse_~ *ordonnée* ~_valeur ordonnée_~
+
*Cercle : rayon* ~_valeur rayon_~
+
Exemple : 
+
 Forme graphique : abscisse 245 ordonnée 189
 Cercle : rayon 17

==== La classe Cylindre

La classe Cylindre est définie comme un cercle avec en plus une hauteur (entier).

Écrire la classe Cylindre. On définira :

.	un héritage éventuel pour la classe (assez évident),
.	le(s) attribut(s) nécessaire(s),
.	un constructeur par défaut initialisant les coordonnées à 0, le rayon à 0 ainsi que la hauteur à 0,
.	un constructeur paramétré permettant d'initialiser correctement toutes les données d'un Cylindre,
.	une méthode accesseur (get) pour chaque attribut défini,
.	une méthode transformateur (set) pour chaque attribut défini,
.	la méthode qui calcule la surface d'un Cylindre (rappel : 2 x PI x rayon x hauteur + 2 x PI x rayon^2^),
.	la méthode qui calcule le volume d'un Cylindre (rappel : PI x rayon^2^ x hauteur),
.	la méthode afficher permettant d'afficher à l'écran le texte suivant. On appelera *obligatoirement* la méthode +afficher()+ de la classe parente.
+
*Forme graphique : abscisse* ~_valeur abcisse_~ *ordonnée* ~_valeur ordonnée_~
+
*Cercle : rayon* ~_valeur rayon_~
+
*Cylindre : hauteur* ~_valeur hauteur_
+
Exemple : 
+
 Forme graphique : abscisse 245 ordonnée 189
 Cercle : rayon 17
 Cylindre : hauteur 789

==== La classe Rectangle

La classe Rectangle est une FormeGraphique comprenant des coordonnées sur le plan x et y (entiers), une hauteur et une largeur (entiers).

Écrire la classe Rectangle. On définira :

.	un héritage éventuel pour la classe,
.	le(s) attribut(s) nécessaire(s),
.	un constructeur par défaut initialisant les coordonnées à 0 ainsi que hauteur/largeur à 0,
.	un constructeur paramétré permettant d'initialiser correctement toutes les données d'un Rectangle,
.	une méthode accesseur (get) pour chaque attribut défini,
.	une méthode transformateur (set) pour chaque attribut défini,
.	la méthode qui calcule la surface d'un Rectangle (rappel : hauteur x largeur),
.	la méthode afficher permettant d'afficher à l'écran le texte suivant. On appelera *obligatoirement* la méthode +afficher()+ de la classe parente.
+
*Forme graphique : abscisse* ~_valeur abcisse_~ *ordonnée* ~_valeur ordonnée_~
+
*Rectangle : hauteur* ~_valeur hauteur_~ *largeur* ~_valeur largeur_~
+
Exemple : 
+
 Forme graphique : abscisse 245 ordonnée 189
 Rectangle : hauteur 43 largeur 128

==== La classe Sphere

La classe Sphere est définie comme un cercle et a une surface et un volume.

Écrire la classe Cercle. On définira :

.	un héritage éventuel pour la classe,
.	le(s) attribut(s) nécessaire(s), réfléchir ... 
.	un constructeur par défaut initialisant les coordonnées à 0 ainsi que le rayon à 0,
.	un constructeur paramétré permettant d'initialiser correctement toutes les données d'une Sphere,
.	une méthode accesseur (get) pour chaque attribut défini,
.	une méthode transformateur (set) pour chaque attribut défini,
.	la méthode qui calcule la surface d'une Sphere (rappel : 4 x PI x rayon^2^),
.	la méthode qui calcule le volume d'une Sphere (rappel : 4 x PI x rayon^3^ / 3),
.	la méthode afficher permettant d'afficher à l'écran le texte suivant. On appelera *obligatoirement* la méthode +afficher()+ de la classe parente.
+
*Forme graphique : abscisse* ~_valeur abcisse_~ *ordonnée* ~_valeur ordonnée_~
+
*Cercle : rayon* ~_valeur rayon_~
+
*Sphere : rayon* ~_valeur hauteur_
+
Exemple : 
+
 Forme graphique : abscisse 245 ordonnée 189
 Cercle : rayon 17
 Sphere : rayon 17
 
==== La classe Carre

La classe Carre est un rectangle particulier puisque la longueur des 2 cotés sont égales.

Écrire la classe Carre. On définira :

.	un héritage éventuel pour la classe,
.	le(s) attribut(s) nécessaire(s),
.	un constructeur par défaut initialisant les coordonnées à 0 ainsi que le côté à 0,
.	un constructeur paramétré permettant d'initialiser correctement un carré : les coordonnées et la longueur du côté,
.	une méthode accesseur (get) pour chaque attribut défini,
.	une méthode transformateur (set) pour chaque attribut défini,
.	à réfléchir : la méthode qui calcule la surface d'un carré (rappel : coté x coté),
.	la méthode afficher permettant d'afficher à l'écran le texte suivant. On appelera *obligatoirement* la méthode +afficher()+ de la classe parente.
+
*Forme graphique : abscisse* ~_valeur abcisse_~ *ordonnée* ~_valeur ordonnée_~
+
*Rectangle : hauteur* ~_valeur hauteur_~ *largeur* ~_valeur largeur_~
+
*Carré : côté* ~_valeur coté_~
Exemple : 
+
 Forme graphique : abscisse 245 ordonnée 189
 Rectangle : hauteur 43 largeur 43
 Carré : côté 43

[NOTE]
=====
Compte tenu de l'héritage utilisé, en utilisant les méthodes transformateurs héritées : arrive-t-on à faire des "carrés qui ne soient pas vraiment carrés" ? 
====

== Pour en arriver au polymorphisme

A la fin du main() écrit :

.	Vous devriez avoir créé 12 objets (12 new, 2 par classe).
.	Insérer la déclaration suivante pour créer un tableau de 12 éléments et y ranger les formes graphiques créées :
+
[source,java]
----
FormeGraphique tabFormes[];

tabFormes = new FormeGraphique [12];

tabFormes[0] = maPremiereFormeGraphique; // variable référençant la première FormeGraphique créée
tabFormes[1] = maDeuxiemeFormeGraphique; // variable référençant la deuxième FormeGraphique créée
tabFormes[3] = monPremierCercle; // variable référençant le premier Cercle créé
tabFormes[4] = monDeuxiemeCercle; // variable référençant le deuxième Cercle créé
tabFormes[5] = monPremierCylindre; // variable référençant le premier Cylindre créé
... // continuer
----
.	Continuer le programme précédent pour y mettre tous les objets créés.
.	Compiler. ok ?
.	Faire une boucle pour appliquer surface(), volume() et afficher() à chaque élément du tableau. Quel est le résultat ?

== Utiliser les méthodes de la super-classe

Dans la classe Cylindre :

.	Mettre en commentaire le corps de la méthode surface() et volume()
.	En écrire une nouvelle version en utilisant la méthode surface() définie dans la classe Cercle. Bien regarder les formules.

On pourra faire de même dans la classe Sphere.

